using System.Reflection;
using System.Text;
using Vibe.CSS.Generator;
using Vibe.CSS.Scanner;

namespace Vibe.CSS.Emitter;

/// <summary>
/// Emits the final CSS output by combining base styles with JIT-generated utilities.
/// </summary>
public class CssEmitter
{
    private readonly UtilityGenerator _generator;
    private readonly ClassScanner _scanner;
    private readonly VibeConfig _config;

    public CssEmitter(VibeConfig? config = null)
    {
        _config = config ?? new VibeConfig();
        _generator = new UtilityGenerator(_config);
        _scanner = new ClassScanner(_config.Prefix);
    }

    /// <summary>
    /// Generate CSS for a project by scanning source files.
    /// </summary>
    /// <param name="projectDirectory">Root directory of the project to scan</param>
    /// <param name="outputPath">Path to write the generated CSS file</param>
    /// <param name="includeBase">Whether to include vibe-base.css content</param>
    public void GenerateForProject(string projectDirectory, string outputPath, bool includeBase = true)
    {
        // Scan for classes
        var usedClasses = _scanner.ScanDirectory(projectDirectory);

        // Generate CSS
        var baseCssPath = Path.Combine(projectDirectory, "wwwroot", "css", "vibe-base.css");
        var css = GenerateCss(usedClasses, includeBase, baseCssPath);

        // Ensure output directory exists
        var outputDir = Path.GetDirectoryName(outputPath);
        if (!string.IsNullOrEmpty(outputDir) && !Directory.Exists(outputDir))
        {
            Directory.CreateDirectory(outputDir);
        }

        // Write output
        File.WriteAllText(outputPath, css);
    }

    /// <summary>
    /// Generate CSS for a set of class names.
    /// </summary>
    /// <param name="classNames">Set of class names to generate CSS for</param>
    /// <param name="includeBase">Whether to include vibe-base.css content</param>
    /// <param name="baseCssPath">Optional path to a project-specific vibe-base.css override</param>
    /// <returns>Generated CSS string</returns>
    public string GenerateCss(IEnumerable<string> classNames, bool includeBase = true, string? baseCssPath = null)
    {
        var sb = new StringBuilder();

        // Header
        sb.AppendLine("/* ========================================");
        sb.AppendLine("   Generated by Vibe.CSS");
        sb.AppendLine($"   Generated at: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
        sb.AppendLine("   ======================================== */");
        sb.AppendLine();

        // Include base CSS
        if (includeBase)
        {
            var baseCSS = GetBaseCss(baseCssPath);
            if (!string.IsNullOrEmpty(baseCSS))
            {
                sb.AppendLine(baseCSS);
                sb.AppendLine();
            }
        }

        // Generate rules for each class
        var rules = new List<CssRule>();
        var generatedClasses = new HashSet<string>();

        foreach (var className in classNames)
        {
            // Skip if already generated (handles duplicates)
            if (generatedClasses.Contains(className))
                continue;

            var classRules = _generator.GenerateAll(className);
            if (classRules.Count > 0)
            {
                rules.AddRange(classRules);
                generatedClasses.Add(className);
            }
        }

        // Sort rules by order for proper cascade
        rules = rules.OrderBy(r => r.Order).ThenBy(r => r.Selector).ToList();

        // Group by media query for cleaner output
        var noMediaRules = rules.Where(r => string.IsNullOrEmpty(r.MediaQuery)).ToList();
        var mediaRules = rules.Where(r => !string.IsNullOrEmpty(r.MediaQuery))
                              .GroupBy(r => r.MediaQuery)
                              .OrderBy(g => GetBreakpointOrder(g.Key!))
                              .ToList();

        // Output non-media rules
        sb.AppendLine("/* ======================================== */");
        sb.AppendLine("/*   Utility Classes                        */");
        sb.AppendLine("/* ======================================== */");
        sb.AppendLine();

        foreach (var rule in noMediaRules)
        {
            sb.AppendLine(rule.ToCss());
        }

        // Output media query rules
        foreach (var group in mediaRules)
        {
            sb.AppendLine();
            sb.AppendLine($"/* {group.Key} */");
            sb.AppendLine($"{group.Key} {{");

            foreach (var rule in group.OrderBy(r => r.Order))
            {
                sb.AppendLine($"  {rule.Selector} {{ {rule.Declarations} }}");
            }

            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    /// <summary>
    /// Generate CSS for content (without scanning files).
    /// </summary>
    /// <param name="content">Content to scan for classes</param>
    /// <param name="includeBase">Whether to include vibe-base.css content</param>
    /// <returns>Generated CSS string</returns>
    public string GenerateForContent(string content, bool includeBase = true)
    {
        var classes = _scanner.ScanContent(content);
        return GenerateCss(classes, includeBase);
    }

    /// <summary>
    /// Get the embedded vibe-base.css content.
    /// </summary>
    private static string GetBaseCss(string? baseCssPath)
    {
        if (!string.IsNullOrWhiteSpace(baseCssPath) && File.Exists(baseCssPath))
        {
            return File.ReadAllText(baseCssPath);
        }

        var assembly = Assembly.GetExecutingAssembly();
        var resourceName = "Vibe.CSS.vibe-base.css";

        using var stream = assembly.GetManifestResourceStream(resourceName);
        if (stream == null)
        {
            // Try alternative resource name
            var names = assembly.GetManifestResourceNames();
            resourceName = names.FirstOrDefault(n => n.EndsWith("vibe-base.css")) ?? string.Empty;

            if (string.IsNullOrEmpty(resourceName))
                return string.Empty;

            using var altStream = assembly.GetManifestResourceStream(resourceName);
            if (altStream == null)
                return string.Empty;

            using var altReader = new StreamReader(altStream);
            return altReader.ReadToEnd();
        }

        using var reader = new StreamReader(stream);
        return reader.ReadToEnd();
    }

    /// <summary>
    /// Get sort order for breakpoints (mobile-first).
    /// </summary>
    private int GetBreakpointOrder(string mediaQuery)
    {
        if (mediaQuery.Contains("640px")) return 1;  // sm
        if (mediaQuery.Contains("768px")) return 2;  // md
        if (mediaQuery.Contains("1024px")) return 3; // lg
        if (mediaQuery.Contains("1280px")) return 4; // xl
        if (mediaQuery.Contains("1536px")) return 5; // 2xl
        return 0;
    }

    /// <summary>
    /// Get statistics about the generated CSS.
    /// </summary>
    public CssStats GetStats(IEnumerable<string> classNames)
    {
        var generated = 0;
        var unknown = new List<string>();

        foreach (var className in classNames)
        {
            var rule = _generator.Generate(className);
            if (rule != null)
            {
                generated++;
            }
            else
            {
                unknown.Add(className);
            }
        }

        return new CssStats
        {
            TotalClasses = classNames.Count(),
            GeneratedClasses = generated,
            UnknownClasses = unknown
        };
    }
}

/// <summary>
/// Statistics about CSS generation.
/// </summary>
public class CssStats
{
    public int TotalClasses { get; init; }
    public int GeneratedClasses { get; init; }
    public List<string> UnknownClasses { get; init; } = [];
    public int UnknownCount => UnknownClasses.Count;
}
