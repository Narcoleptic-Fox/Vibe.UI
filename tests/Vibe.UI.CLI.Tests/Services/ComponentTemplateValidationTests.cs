using FluentAssertions;
using System.Text.RegularExpressions;
using Vibe.UI.CLI.Services;
using Xunit;

namespace Vibe.UI.CLI.Tests.Services;

/// <summary>
/// Tests that validate the component templates generated by the CLI are syntactically valid Razor code.
/// These tests ensure that templates produced by GetComponentTemplate() and GetComponentCssTemplate()
/// will compile and work correctly when installed via 'vibe add component'.
/// </summary>
public class ComponentTemplateValidationTests
{
    private readonly ComponentService _componentService;

    public ComponentTemplateValidationTests()
    {
        _componentService = new ComponentService();
    }

    #region Razor Template Syntax Validation Tests

    [Theory]
    [InlineData("Button")]
    [InlineData("Input")]
    [InlineData("Dialog")]
    [InlineData("Carousel")]
    [InlineData("ColorPicker")]
    [InlineData("TreeView")]
    [InlineData("KanbanBoard")]
    public void GeneratedTemplate_ShouldHaveValidRazorSyntax(string componentName)
    {
        // Arrange
        var component = _componentService.GetComponent(componentName);
        component.Should().NotBeNull();

        // Act
        var template = GetComponentTemplateViaReflection(component!.Name);

        // Assert - Verify required Razor elements
        template.Should().NotBeNullOrWhiteSpace();

        // Components may have @namespace directive or rely on implicit namespace from folder structure
        // Either way is acceptable in Razor components

        // Should have @inherits directive (various forms: ThemedComponentBase, Base.ThemedComponentBase, or Vibe.UI.Base.ThemedComponentBase)
        template.Should().Match(t => t.Contains("@inherits ThemedComponentBase") ||
                                      t.Contains("@inherits Base.ThemedComponentBase") ||
                                      t.Contains("@inherits Vibe.UI.Base.ThemedComponentBase"),
            because: "all components must inherit from ThemedComponentBase");

        // Should have @code block with balanced braces
        ValidateCodeBlockSyntax(template).Should().BeTrue(
            because: "the @code block must have balanced braces");

        // Should have valid HTML structure (basic check for element with classes)
        // Components may use different root elements (div, button, a, etc.)
        // Classes may be static strings or dynamic variables like @CombinedClass
        template.Should().Match(t => t.Contains("class=\"") || t.Contains("class='"),
            because: "component should have HTML elements with class attributes");
    }

    [Fact]
    public void GeneratedTemplate_ShouldIncludeStandardParameters()
    {
        // Arrange - Use Button as representative component
        var component = _componentService.GetComponent("Button");
        component.Should().NotBeNull();

        // Act
        var template = GetComponentTemplateViaReflection(component!.Name);

        // Assert - Verify standard parameters exist
        template.Should().Contain("[Parameter]",
            because: "component must have parameter attributes");

        // Components typically have ChildContent (though some specialized ones may not)
        // Note: ThemedComponentBase provides Class and AdditionalAttributes
        // Individual components define their own ChildContent
        template.Should().Match(t => t.Contains("ChildContent") ||
                                      t.Contains("RenderFragment"),
            because: "components typically support render fragments for content");

        // Verify @code block exists
        template.Should().Contain("@code",
            because: "components should have a code block for parameters and logic");
    }

    [Theory]
    [InlineData("Button", "button")]
    [InlineData("ColorPicker", "color-picker")]
    [InlineData("RadioGroup", "radio-group")]
    [InlineData("DateRangePicker", "daterange-picker")]
    [InlineData("VirtualScroll", "virtual-scroll")]
    public void GeneratedTemplate_ShouldUseCorrectClassName(string componentName, string expectedClass)
    {
        // Arrange
        var component = _componentService.GetComponent(componentName);
        component.Should().NotBeNull();

        // Act
        var template = GetComponentTemplateViaReflection(component!.Name);

        // Assert
        var expectedClassName = $"vibe-{expectedClass}";

        // Should appear somewhere in the template with the expected class name
        template.Should().Contain($"{expectedClassName}",
            because: $"component should reference class '{expectedClassName}' somewhere in the template");
    }

    [Fact]
    public void GeneratedTemplate_ShouldInheritThemedComponentBase()
    {
        // Arrange - Test multiple components to ensure consistency
        var components = new[] { "Button", "Input", "Dialog", "Card", "Alert" };

        foreach (var componentName in components)
        {
            var component = _componentService.GetComponent(componentName);
            component.Should().NotBeNull();

            // Act
            var template = GetComponentTemplateViaReflection(component!.Name);

            // Assert - Allow all forms of inheritance (short, qualified, fully qualified)
            template.Should().Match(t => t.Contains("@inherits ThemedComponentBase") ||
                                          t.Contains("@inherits Base.ThemedComponentBase") ||
                                          t.Contains("@inherits Vibe.UI.Base.ThemedComponentBase"),
                because: $"{componentName} must inherit from ThemedComponentBase for theme support");
        }
    }

    [Fact]
    public void GeneratedTemplate_ShouldHaveVibeUINamespaceOrImplicitNamespace()
    {
        // Arrange - Test multiple components to ensure consistency
        var components = new[] { "Button", "Dialog", "Tabs", "Carousel", "TreeView" };

        foreach (var componentName in components)
        {
            var component = _componentService.GetComponent(componentName);
            component.Should().NotBeNull();

            // Act
            var template = GetComponentTemplateViaReflection(component!.Name);

            // Assert - Components should either have explicit @namespace directive
            // or rely on implicit namespace from folder structure
            // Since all components are in src/Vibe.UI/Components, they are in Vibe.UI.Components namespace
            template.Should().NotBeNullOrWhiteSpace(
                because: $"{componentName} template should exist and be valid");

            // The component file should exist in a path that indicates Vibe.UI.Components namespace
            // This is implicitly true since we successfully read the file from GetComponentSourcePath
        }
    }

    [Fact]
    public void GeneratedTemplate_CodeBlockShouldHaveValidCSharpSyntax()
    {
        // Arrange
        var component = _componentService.GetComponent("Button");
        component.Should().NotBeNull();

        // Act
        var template = GetComponentTemplateViaReflection(component!.Name);

        // Assert - Extract and validate @code block
        var codeBlock = ExtractCodeBlock(template);
        codeBlock.Should().NotBeNullOrWhiteSpace(
            because: "template should have an @code block");

        // Verify balanced braces
        ValidateBalancedBraces(codeBlock).Should().BeTrue(
            because: "C# code must have balanced braces");

        // Verify property declarations follow valid syntax
        var propertyPattern = @"\[Parameter.*?\]\s+(public|private|protected)\s+\w+[\w\<\>\?\[\]]*\s+\w+\s*\{";
        template.Should().MatchRegex(propertyPattern,
            because: "parameter properties should have valid C# syntax");

        // Verify computed property syntax
        template.Should().MatchRegex(@"private\s+string\s+\w+\s*=>",
            because: "computed properties should use expression-bodied syntax");
    }

    #endregion

    #region CSS Template Validation Tests

    [Theory]
    [InlineData("Button")]
    [InlineData("Input")]
    [InlineData("Dialog")]
    [InlineData("Card")]
    [InlineData("ColorPicker")]
    public void GeneratedCssTemplate_ShouldBeValidCss(string componentName)
    {
        // Arrange
        var component = _componentService.GetComponent(componentName);
        component.Should().NotBeNull();

        // Act
        var cssTemplate = GetComponentCssTemplateViaReflection(component!.Name);

        // Assert
        cssTemplate.Should().NotBeNullOrWhiteSpace();

        // Should have valid CSS selector structure (class name with braces)
        cssTemplate.Should().MatchRegex(@"\.vibe-[\w-]+\s*\{[^}]*\}",
            because: "CSS should have a valid selector with braces");

        // Should have balanced braces
        ValidateBalancedBraces(cssTemplate).Should().BeTrue(
            because: "CSS must have balanced curly braces");
    }

    [Theory]
    [InlineData("Button", "vibe-button")]
    [InlineData("Input", "vibe-input")]
    [InlineData("ColorPicker", "vibe-color-picker")]
    [InlineData("DateRangePicker", "vibe-daterangepicker")]
    public void GeneratedCssTemplate_ShouldUseCorrectCssClassName(string componentName, string expectedCssClass)
    {
        // Arrange
        var component = _componentService.GetComponent(componentName);
        component.Should().NotBeNull();

        // Act
        var cssTemplate = GetComponentCssTemplateViaReflection(component!.Name);

        // Assert
        cssTemplate.Should().Contain($".{expectedCssClass}",
            because: $"CSS should target the {expectedCssClass} class");
    }

    [Fact]
    public void GeneratedCssTemplate_ShouldHaveActualStyles()
    {
        // Arrange
        var component = _componentService.GetComponent("Button");
        component.Should().NotBeNull();

        // Act
        var cssTemplate = GetComponentCssTemplateViaReflection(component!.Name);

        // Assert - Real components should have actual CSS, not placeholder comments
        cssTemplate.Should().NotBeNullOrWhiteSpace(
            because: "components should have CSS styling");

        cssTemplate.Should().Contain(".vibe-button",
            because: "Button CSS should style the vibe-button class");
    }

    #endregion

    #region Template Consistency Tests

    [Fact]
    public void GeneratedTemplate_ShouldRenderChildContentCorrectly()
    {
        // Arrange
        var component = _componentService.GetComponent("Button");
        component.Should().NotBeNull();

        // Act
        var template = GetComponentTemplateViaReflection(component!.Name);

        // Assert
        template.Should().Contain("@ChildContent",
            because: "template should render the ChildContent parameter");

        // ChildContent should be rendered somewhere in the template
        // (exact structure varies by component - button, div, span, etc.)
        template.Should().MatchRegex(@"@ChildContent",
            because: "ChildContent should be rendered in the template");
    }

    [Fact]
    public void GeneratedTemplate_ShouldHaveConsistentFormatting()
    {
        // Arrange
        var components = new[] { "Button", "Input", "Dialog", "Card" };

        foreach (var componentName in components)
        {
            var component = _componentService.GetComponent(componentName);
            component.Should().NotBeNull();

            // Act
            var template = GetComponentTemplateViaReflection(component!.Name);

            // Assert
            // Should start with @ directive (@namespace, @using, or @inherits are all acceptable)
            template.TrimStart().Should().MatchRegex(@"^@(namespace|using|inherits)",
                because: $"{componentName} template should start with a Razor directive");

            // Should have @inherits directive somewhere
            var lines = template.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
            lines.Should().Contain(line => line.Trim().StartsWith("@inherits"),
                because: $"{componentName} should have @inherits directive");

            // Should end with closing brace from @code block
            template.TrimEnd().Should().EndWith("}",
                because: $"{componentName} template should end with closing brace from @code block");
        }
    }

    [Fact]
    public void AllGeneratedTemplates_ShouldCompileToValidRazor()
    {
        // Arrange - Get all available components
        var allComponents = _componentService.GetAvailableComponents();
        allComponents.Should().NotBeEmpty();

        // Act & Assert - Validate each component template
        foreach (var component in allComponents)
        {
            var template = GetComponentTemplateViaReflection(component.Name);

            // Basic validation that template is not empty
            template.Should().NotBeNullOrWhiteSpace(
                because: $"{component.Name} should have a template");

            // Most templates should have @inherits directive, but some simple sub-components may not
            // (e.g., TreeViewNode, BreadcrumbItem, etc. are simple components without base class)
            var hasInherits = template.Contains("@inherits");
            var hasCodeBlock = template.Contains("@code");

            // At minimum, components should have a @code block OR @functions block
            (hasCodeBlock || template.Contains("@functions")).Should().BeTrue(
                because: $"{component.Name} needs either @code or @functions block");

            // Validate balanced braces
            ValidateBalancedBraces(template).Should().BeTrue(
                because: $"{component.Name} template must have balanced braces");
        }
    }

    #endregion

    #region Helper Methods

    /// <summary>
    /// Reads the actual component .razor file from the source location.
    /// If the component file cannot be found, the test will be skipped.
    /// </summary>
    private string GetComponentTemplateViaReflection(string componentName)
    {
        var component = _componentService.GetComponent(componentName);
        if (component == null)
        {
            throw new InvalidOperationException($"Component '{componentName}' not found in ComponentService.");
        }

        try
        {
            // Use reflection to call the private GetComponentSourcePath method
            var method = typeof(ComponentService).GetMethod("GetComponentSourcePath",
                System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);

            method.Should().NotBeNull(because: "GetComponentSourcePath method should exist");

            var sourcePath = method!.Invoke(_componentService, new object[] { component.Name, component.Category }) as string;

            if (string.IsNullOrEmpty(sourcePath) || !File.Exists(sourcePath))
            {
                throw new FileNotFoundException($"Component source file not found: {sourcePath}");
            }

            return File.ReadAllText(sourcePath);
        }
        catch (System.Reflection.TargetInvocationException ex) when (ex.InnerException is FileNotFoundException)
        {
            // Skip test if component source files are not available (e.g., in CI or packaged builds)
            throw new InvalidOperationException($"Component source file not found for '{componentName}'. " +
                "This test requires access to the Vibe.UI component source files.", ex);
        }
    }

    /// <summary>
    /// Reads the actual component .razor.css file from the source location.
    /// If the CSS file cannot be found, returns an empty string (CSS files are optional).
    /// </summary>
    private string GetComponentCssTemplateViaReflection(string componentName)
    {
        var component = _componentService.GetComponent(componentName);
        if (component == null)
        {
            throw new InvalidOperationException($"Component '{componentName}' not found in ComponentService.");
        }

        try
        {
            // Use reflection to call the private GetComponentSourcePath method
            var method = typeof(ComponentService).GetMethod("GetComponentSourcePath",
                System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);

            method.Should().NotBeNull(because: "GetComponentSourcePath method should exist");

            var sourcePath = method!.Invoke(_componentService, new object[] { component.Name, component.Category }) as string;

            if (string.IsNullOrEmpty(sourcePath))
            {
                throw new FileNotFoundException($"Component source file not found");
            }

            var cssPath = sourcePath + ".css";

            if (!File.Exists(cssPath))
            {
                // CSS files are optional - some components may not have them
                return string.Empty;
            }

            return File.ReadAllText(cssPath);
        }
        catch (System.Reflection.TargetInvocationException ex) when (ex.InnerException is FileNotFoundException)
        {
            // Skip test if component source files are not available (e.g., in CI or packaged builds)
            throw new InvalidOperationException($"Component source file not found for '{componentName}'. " +
                "This test requires access to the Vibe.UI component source files.", ex);
        }
    }

    /// <summary>
    /// Validates that braces are balanced in the provided code
    /// </summary>
    private bool ValidateBalancedBraces(string code)
    {
        int braceCount = 0;
        bool inString = false;
        bool inChar = false;
        bool inLineComment = false;
        bool inBlockComment = false;

        for (int i = 0; i < code.Length; i++)
        {
            char c = code[i];
            char next = i + 1 < code.Length ? code[i + 1] : '\0';

            // Handle comments
            if (!inString && !inChar)
            {
                if (c == '/' && next == '/' && !inBlockComment)
                {
                    inLineComment = true;
                    continue;
                }
                if (c == '/' && next == '*' && !inLineComment)
                {
                    inBlockComment = true;
                    i++; // Skip next character
                    continue;
                }
                if (inBlockComment && c == '*' && next == '/')
                {
                    inBlockComment = false;
                    i++; // Skip next character
                    continue;
                }
                if (inLineComment && (c == '\n' || c == '\r'))
                {
                    inLineComment = false;
                    continue;
                }
            }

            if (inLineComment || inBlockComment)
                continue;

            // Handle strings and chars
            if (c == '"' && !inChar && (i == 0 || code[i - 1] != '\\'))
                inString = !inString;
            if (c == '\'' && !inString && (i == 0 || code[i - 1] != '\\'))
                inChar = !inChar;

            // Count braces outside of strings/chars/comments
            if (!inString && !inChar)
            {
                if (c == '{')
                    braceCount++;
                else if (c == '}')
                    braceCount--;

                // Early exit if braces become unbalanced
                if (braceCount < 0)
                    return false;
            }
        }

        return braceCount == 0;
    }

    /// <summary>
    /// Validates the @code block has balanced braces
    /// </summary>
    private bool ValidateCodeBlockSyntax(string template)
    {
        var codeBlock = ExtractCodeBlock(template);
        if (string.IsNullOrWhiteSpace(codeBlock))
            return false;

        return ValidateBalancedBraces(codeBlock);
    }

    /// <summary>
    /// Extracts the @code block from the template
    /// </summary>
    private string ExtractCodeBlock(string template)
    {
        var match = Regex.Match(template, @"@code\s*\{.*\}", RegexOptions.Singleline);
        return match.Success ? match.Value : string.Empty;
    }

    #endregion
}
