using FluentAssertions;
using System.Text.RegularExpressions;
using Vibe.UI.CLI.Services;
using Xunit;

namespace Vibe.UI.CLI.Tests.Services;

/// <summary>
/// Tests that validate the component templates generated by the CLI are syntactically valid Razor code.
/// These tests ensure that templates produced by GetComponentTemplate() and GetComponentCssTemplate()
/// will compile and work correctly when installed via 'vibe add component'.
/// </summary>
public class ComponentTemplateValidationTests
{
    private readonly ComponentService _componentService;

    public ComponentTemplateValidationTests()
    {
        _componentService = new ComponentService();
    }

    #region Razor Template Syntax Validation Tests

    [Theory]
    [InlineData("Button")]
    [InlineData("Input")]
    [InlineData("Dialog")]
    [InlineData("Carousel")]
    [InlineData("ColorPicker")]
    [InlineData("TreeView")]
    [InlineData("KanbanBoard")]
    public void GeneratedTemplate_ShouldHaveValidRazorSyntax(string componentName)
    {
        // Arrange
        var component = _componentService.GetComponent(componentName);
        component.Should().NotBeNull();

        // Act
        var template = GetComponentTemplateViaReflection(component!.Name);

        // Assert - Verify required Razor elements
        template.Should().NotBeNullOrWhiteSpace();

        // Should have @namespace directive
        template.Should().Contain("@namespace Vibe.UI.Components",
            because: "all components must declare the Vibe.UI.Components namespace");

        // Should have @inherits directive
        template.Should().Contain("@inherits ThemedComponentBase",
            because: "all components must inherit from ThemedComponentBase");

        // Should have @code block with balanced braces
        ValidateCodeBlockSyntax(template).Should().BeTrue(
            because: "the @code block must have balanced braces");

        // Should have valid HTML structure (basic check for div with class)
        template.Should().MatchRegex(@"<div\s+class=""vibe-[\w-]+"">",
            because: "component should have a root div with a vibe- prefixed class");
    }

    [Fact]
    public void GeneratedTemplate_ShouldIncludeStandardParameters()
    {
        // Arrange - Use Button as representative component
        var component = _componentService.GetComponent("Button");
        component.Should().NotBeNull();

        // Act
        var template = GetComponentTemplateViaReflection(component!.Name);

        // Assert - Verify standard parameters exist
        template.Should().Contain("[Parameter]",
            because: "component must have parameter attributes");

        template.Should().Contain("public RenderFragment? ChildContent { get; set; }",
            because: "components should support child content");

        template.Should().Contain("public string? CssClass { get; set; }",
            because: "components should support custom CSS classes");

        template.Should().Contain("[Parameter(CaptureUnmatchedValues = true)]",
            because: "components should capture unmatched attributes");

        template.Should().Contain("public Dictionary<string, object>? AdditionalAttributes { get; set; }",
            because: "components should support additional HTML attributes");

        // Should have CombinedCssClass property
        template.Should().Contain("private string CombinedCssClass =>",
            because: "components should have a computed CSS class property");

        template.Should().Contain("CombineClasses(",
            because: "components should use the CombineClasses helper method");
    }

    [Theory]
    [InlineData("Button", "button")]
    [InlineData("ColorPicker", "colorpicker")]
    [InlineData("RadioGroup", "radiogroup")]
    [InlineData("DateRangePicker", "daterangepicker")]
    [InlineData("VirtualScroll", "virtualscroll")]
    public void GeneratedTemplate_ShouldUseCorrectClassName(string componentName, string expectedClass)
    {
        // Arrange
        var component = _componentService.GetComponent(componentName);
        component.Should().NotBeNull();

        // Act
        var template = GetComponentTemplateViaReflection(component!.Name);

        // Assert
        var expectedClassName = $"vibe-{expectedClass}";

        // Should appear in the HTML markup
        template.Should().Contain($@"class=""vibe-{expectedClass}""",
            because: $"component should have class '{expectedClassName}' in markup");

        // Should appear in the CombineClasses call
        template.Should().Contain($@"""{expectedClassName}""",
            because: $"component should reference '{expectedClassName}' in CombineClasses");
    }

    [Fact]
    public void GeneratedTemplate_ShouldInheritThemedComponentBase()
    {
        // Arrange - Test multiple components to ensure consistency
        var components = new[] { "Button", "Input", "Dialog", "Card", "Alert" };

        foreach (var componentName in components)
        {
            var component = _componentService.GetComponent(componentName);
            component.Should().NotBeNull();

            // Act
            var template = GetComponentTemplateViaReflection(component!.Name);

            // Assert
            template.Should().Contain("@inherits ThemedComponentBase",
                because: $"{componentName} must inherit from ThemedComponentBase for theme support");
        }
    }

    [Fact]
    public void GeneratedTemplate_ShouldHaveVibeUINamespace()
    {
        // Arrange - Test multiple components to ensure consistency
        var components = new[] { "Button", "Dialog", "Tabs", "Carousel", "TreeView" };

        foreach (var componentName in components)
        {
            var component = _componentService.GetComponent(componentName);
            component.Should().NotBeNull();

            // Act
            var template = GetComponentTemplateViaReflection(component!.Name);

            // Assert
            template.Should().Contain("@namespace Vibe.UI.Components",
                because: $"{componentName} must be in the Vibe.UI.Components namespace");
        }
    }

    [Fact]
    public void GeneratedTemplate_CodeBlockShouldHaveValidCSharpSyntax()
    {
        // Arrange
        var component = _componentService.GetComponent("Button");
        component.Should().NotBeNull();

        // Act
        var template = GetComponentTemplateViaReflection(component!.Name);

        // Assert - Extract and validate @code block
        var codeBlock = ExtractCodeBlock(template);
        codeBlock.Should().NotBeNullOrWhiteSpace(
            because: "template should have an @code block");

        // Verify balanced braces
        ValidateBalancedBraces(codeBlock).Should().BeTrue(
            because: "C# code must have balanced braces");

        // Verify property declarations follow valid syntax
        var propertyPattern = @"\[Parameter.*?\]\s+(public|private|protected)\s+\w+[\w\<\>\?\[\]]*\s+\w+\s*\{";
        template.Should().MatchRegex(propertyPattern,
            because: "parameter properties should have valid C# syntax");

        // Verify computed property syntax
        template.Should().MatchRegex(@"private\s+string\s+\w+\s*=>",
            because: "computed properties should use expression-bodied syntax");
    }

    #endregion

    #region CSS Template Validation Tests

    [Theory]
    [InlineData("Button")]
    [InlineData("Input")]
    [InlineData("Dialog")]
    [InlineData("Card")]
    [InlineData("ColorPicker")]
    public void GeneratedCssTemplate_ShouldBeValidCss(string componentName)
    {
        // Arrange
        var component = _componentService.GetComponent(componentName);
        component.Should().NotBeNull();

        // Act
        var cssTemplate = GetComponentCssTemplateViaReflection(component!.Name);

        // Assert
        cssTemplate.Should().NotBeNullOrWhiteSpace();

        // Should have valid CSS selector structure (class name with braces)
        cssTemplate.Should().MatchRegex(@"\.vibe-[\w-]+\s*\{[^}]*\}",
            because: "CSS should have a valid selector with braces");

        // Should have balanced braces
        ValidateBalancedBraces(cssTemplate).Should().BeTrue(
            because: "CSS must have balanced curly braces");
    }

    [Theory]
    [InlineData("Button", "vibe-button")]
    [InlineData("Input", "vibe-input")]
    [InlineData("ColorPicker", "vibe-colorpicker")]
    [InlineData("DateRangePicker", "vibe-daterangepicker")]
    public void GeneratedCssTemplate_ShouldUseCorrectCssClassName(string componentName, string expectedCssClass)
    {
        // Arrange
        var component = _componentService.GetComponent(componentName);
        component.Should().NotBeNull();

        // Act
        var cssTemplate = GetComponentCssTemplateViaReflection(component!.Name);

        // Assert
        cssTemplate.Should().Contain($".{expectedCssClass}",
            because: $"CSS should target the {expectedCssClass} class");
    }

    [Fact]
    public void GeneratedCssTemplate_ShouldHaveCommentPlaceholder()
    {
        // Arrange
        var component = _componentService.GetComponent("Button");
        component.Should().NotBeNull();

        // Act
        var cssTemplate = GetComponentCssTemplateViaReflection(component!.Name);

        // Assert
        cssTemplate.Should().Contain("/* Add component styles here */",
            because: "CSS template should have a helpful comment for developers");
    }

    #endregion

    #region Template Consistency Tests

    [Fact]
    public void GeneratedTemplate_ShouldRenderChildContentCorrectly()
    {
        // Arrange
        var component = _componentService.GetComponent("Button");
        component.Should().NotBeNull();

        // Act
        var template = GetComponentTemplateViaReflection(component!.Name);

        // Assert
        template.Should().Contain("@ChildContent",
            because: "template should render the ChildContent parameter");

        // ChildContent should be rendered within the component's div
        var divBlockPattern = @"<div[^>]*>\s*@ChildContent\s*</div>";
        template.Should().MatchRegex(divBlockPattern,
            because: "ChildContent should be rendered inside the component div");
    }

    [Fact]
    public void GeneratedTemplate_ShouldHaveConsistentFormatting()
    {
        // Arrange
        var components = new[] { "Button", "Input", "Dialog", "Card" };

        foreach (var componentName in components)
        {
            var component = _componentService.GetComponent(componentName);
            component.Should().NotBeNull();

            // Act
            var template = GetComponentTemplateViaReflection(component!.Name);

            // Assert
            // Should start with @namespace directive
            template.TrimStart().Should().StartWith("@namespace",
                because: $"{componentName} template should start with @namespace directive");

            // Should have @inherits as second directive
            var lines = template.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
            lines.Should().Contain(line => line.Trim().StartsWith("@inherits"),
                because: $"{componentName} should have @inherits directive");

            // Should end with closing brace from @code block
            template.TrimEnd().Should().EndWith("}",
                because: $"{componentName} template should end with closing brace from @code block");
        }
    }

    [Fact]
    public void AllGeneratedTemplates_ShouldCompileToValidRazor()
    {
        // Arrange - Get all available components
        var allComponents = _componentService.GetAvailableComponents();
        allComponents.Should().NotBeEmpty();

        // Act & Assert - Validate each component template
        foreach (var component in allComponents)
        {
            var template = GetComponentTemplateViaReflection(component.Name);

            // Basic validation that template is not empty
            template.Should().NotBeNullOrWhiteSpace(
                because: $"{component.Name} should have a template");

            // All templates should have the required directives
            template.Should().Contain("@namespace",
                because: $"{component.Name} needs namespace directive");
            template.Should().Contain("@inherits",
                because: $"{component.Name} needs inherits directive");
            template.Should().Contain("@code",
                because: $"{component.Name} needs code block");

            // Validate balanced braces
            ValidateBalancedBraces(template).Should().BeTrue(
                because: $"{component.Name} template must have balanced braces");
        }
    }

    #endregion

    #region Helper Methods

    /// <summary>
    /// Uses reflection to access the private GetComponentTemplate method
    /// </summary>
    private string GetComponentTemplateViaReflection(string componentName)
    {
        var method = typeof(ComponentService).GetMethod("GetComponentTemplate",
            System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);

        method.Should().NotBeNull(because: "GetComponentTemplate method should exist");

        var result = method!.Invoke(_componentService, new object[] { componentName });
        return result as string ?? string.Empty;
    }

    /// <summary>
    /// Uses reflection to access the private GetComponentCssTemplate method
    /// </summary>
    private string GetComponentCssTemplateViaReflection(string componentName)
    {
        var method = typeof(ComponentService).GetMethod("GetComponentCssTemplate",
            System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);

        method.Should().NotBeNull(because: "GetComponentCssTemplate method should exist");

        var result = method!.Invoke(_componentService, new object[] { componentName });
        return result as string ?? string.Empty;
    }

    /// <summary>
    /// Validates that braces are balanced in the provided code
    /// </summary>
    private bool ValidateBalancedBraces(string code)
    {
        int braceCount = 0;
        bool inString = false;
        bool inChar = false;
        bool inLineComment = false;
        bool inBlockComment = false;

        for (int i = 0; i < code.Length; i++)
        {
            char c = code[i];
            char next = i + 1 < code.Length ? code[i + 1] : '\0';

            // Handle comments
            if (!inString && !inChar)
            {
                if (c == '/' && next == '/' && !inBlockComment)
                {
                    inLineComment = true;
                    continue;
                }
                if (c == '/' && next == '*' && !inLineComment)
                {
                    inBlockComment = true;
                    i++; // Skip next character
                    continue;
                }
                if (inBlockComment && c == '*' && next == '/')
                {
                    inBlockComment = false;
                    i++; // Skip next character
                    continue;
                }
                if (inLineComment && (c == '\n' || c == '\r'))
                {
                    inLineComment = false;
                    continue;
                }
            }

            if (inLineComment || inBlockComment)
                continue;

            // Handle strings and chars
            if (c == '"' && !inChar && (i == 0 || code[i - 1] != '\\'))
                inString = !inString;
            if (c == '\'' && !inString && (i == 0 || code[i - 1] != '\\'))
                inChar = !inChar;

            // Count braces outside of strings/chars/comments
            if (!inString && !inChar)
            {
                if (c == '{')
                    braceCount++;
                else if (c == '}')
                    braceCount--;

                // Early exit if braces become unbalanced
                if (braceCount < 0)
                    return false;
            }
        }

        return braceCount == 0;
    }

    /// <summary>
    /// Validates the @code block has balanced braces
    /// </summary>
    private bool ValidateCodeBlockSyntax(string template)
    {
        var codeBlock = ExtractCodeBlock(template);
        if (string.IsNullOrWhiteSpace(codeBlock))
            return false;

        return ValidateBalancedBraces(codeBlock);
    }

    /// <summary>
    /// Extracts the @code block from the template
    /// </summary>
    private string ExtractCodeBlock(string template)
    {
        var match = Regex.Match(template, @"@code\s*\{.*\}", RegexOptions.Singleline);
        return match.Success ? match.Value : string.Empty;
    }

    #endregion
}
